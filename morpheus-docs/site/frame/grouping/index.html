<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Xavier Witdouck">
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Grouping - Morpheus</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../.././css/morpheus.css" rel="stylesheet">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../..">Morpheus</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="../..">Overview</a>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Array <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../array/overview/">Overview</a>
</li>
                            
<li >
    <a href="../../array/performance/">Performance</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">DataFrame <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../construction/">Construction</a>
</li>
                            
<li >
    <a href="../access/">Accessing</a>
</li>
                            
<li >
    <a href="../reshaping/">Reshaping</a>
</li>
                            
<li >
    <a href="../filtering/">Filtering</a>
</li>
                            
<li >
    <a href="../sorting/">Sorting</a>
</li>
                            
<li class="active">
    <a href="./">Grouping</a>
</li>
                            
<li >
    <a href="../finding/">Finding</a>
</li>
                            
<li >
    <a href="../writing/">Writing</a>
</li>
                            
<li >
    <a href="../performance/">Performance</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Analysis <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../analysis/statistics/">Descriptive Statistics</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">Linear Regression</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../regression/ols/">Ordinary Least Squares</a>
</li>
            
<li >
    <a href="../../regression/wls/">Weighted Least Squares</a>
</li>
            
<li >
    <a href="../../regression/gls/">Generalized Least Squares</a>
</li>
    </ul>
  </li>
                            
<li >
    <a href="../../analysis/pca/">Principal Component Analysis</a>
</li>
                            
<li >
    <a href="../../analysis/linearalgebra/">Linear Algebra</a>
</li>
                            
<li >
    <a href="../../analysis/timeseries/">Time Series Analysis</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">Examples</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../examples/mpt/">Modern Portfolio Theory</a>
</li>
    </ul>
  </li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Visualization <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
  <li class="dropdown-submenu">
    <a href="#">Charts</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../viz/charts/overview/">Overview</a>
</li>
            
<li >
    <a href="../../viz/charts/embed/">Embedding (HTML)</a>
</li>
            
<li >
    <a href="../../viz/charts/gallery1/">Gallery (Google)</a>
</li>
            
<li >
    <a href="../../viz/charts/gallery2/">Gallery (JFree)</a>
</li>
    </ul>
  </li>
                            
<li >
    <a href="../../viz/tables/overview/">Tables</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Data Sources <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../providers/quandl/">Quandl</a>
</li>
                            
<li >
    <a href="../../providers/fred/">Federal Reserve</a>
</li>
                            
<li >
    <a href="../../providers/google/">Google Finance</a>
</li>
                            
<li >
    <a href="../../providers/yahoo/">Yahoo Finance</a>
</li>
                            
<li >
    <a href="../../providers/world-bank/">World Bank</a>
</li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../sorting/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../finding/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/zavtech/morpheus-core">
                                <i class="fa fa-github"></i>GitHub
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#grouping">Grouping</a></li>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#example-data">Example Data</a></li>
            <li><a href="#grouping-rows">Grouping Rows</a></li>
            <li><a href="#grouping-columns">Grouping Columns</a></li>
            <li><a href="#performance">Performance</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h3 id="grouping">Grouping</h3>
<h4 id="introduction">Introduction</h4>
<p>The contents of a Morpheus <code>DataFrame</code> can be grouped in either the row or column dimension making it easy 
to aggregate and compute summary statistics on these groups. A group is nothing more than a <code>DataFrame</code> filter, 
so grouping even large frames has fairly modest memory requirements. Grouping functions can operate in
either sequential mode or parallel mode for improved performance on large frames. Finally, rows or columns 
can be grouped based on derived data, not just from data that exists in the frame. For example, if a <code>DataFrame</code> 
contains a column with dates, it is possible to group the data into months without adding an explicit column 
to capture the month associated with each date (see examples below).</p>
<h4 id="example-data">Example Data</h4>
<p>In this section, we will continue to use the ATP 2013 dataset that was introduced earlier in the filtering 
discussion <a href="../filtering/#example-data">here</a>. This dataset makes for an ideal grouping candidate given the large 
number of categorical items such as <code>Surface</code>, <code>Tournament</code>, <code>Round</code> and so on. As a reminder, here are the first 
10 rows of the 2013 ATP match <code>DataFrame</code>.</p>
<div class="frame"><pre class="frame">
 Index  |  Location  |        Tournament        |     Date     |  Series  |   Court   |  Surface  |    Round    |  Best of  |     Winner     |     Loser      |  WRank  |  LRank  |  WPts  |  LPts  |  W1  |  L1  |  W2  |  L2  |  W3  |  L3  |  W4  |  L4  |  W5  |  L5  |  Wsets  |  Lsets  |   Comment   |  B365W   |  B365L   |   EXW    |   EXL    |   LBW    |   LBL    |   PSW    |   PSL    |   SJW    |   SJL    |   MaxW   |   MaxL   |   AvgW   |   AvgL   |
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     0  |  Brisbane  |  Brisbane International  |  2012-12-31  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |      Mayer F.  |    Giraldo S.  |     28  |     57  |  1215  |   778  |   6  |   4  |   6  |   4  |   0  |   0  |   0  |   0  |   0  |   0  |      2  |      0  |  Completed  |  1.3600  |  3.0000  |  1.4500  |  2.6500  |  1.4400  |  2.6200  |  1.4700  |  2.8500  |  1.4400  |  2.6300  |  1.4700  |  3.2000  |  1.4200  |  2.7800  |
     1  |  Brisbane  |  Brisbane International  |  2012-12-31  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |   Nieminen J.  |  Benneteau J.  |     41  |     35  |   927  |  1075  |   6  |   3  |   2  |   6  |   6  |   1  |   0  |   0  |   0  |   0  |      2  |      1  |  Completed  |  1.6100  |  2.2000  |  1.7500  |  2.0000  |  1.8000  |  1.9100  |  1.8000  |  2.1000  |  1.7300  |  2.0000  |  1.8000  |  2.2600  |  1.7300  |  2.0500  |
     2  |  Brisbane  |  Brisbane International  |  2012-12-31  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |  Nishikori K.  |  Matosevic M.  |     19  |     49  |  1830  |   845  |   7  |   5  |   6  |   2  |   0  |   0  |   0  |   0  |   0  |   0  |      2  |      0  |  Completed  |  1.2500  |  3.7500  |  1.2500  |  3.7500  |  1.2900  |  3.5000  |  1.3000  |  3.8500  |  1.3000  |  3.2000  |  1.3000  |  4.2000  |  1.2800  |  3.5800  |
     3  |  Brisbane  |  Brisbane International  |  2012-12-31  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |  Baghdatis M.  |   Mitchell B.  |     36  |    326  |  1070  |   137  |   6  |   4  |   6  |   4  |   0  |   0  |   0  |   0  |   0  |   0  |      2  |      0  |  Completed  |  1.0700  |  9.0000  |  1.0600  |  8.0000  |  1.0800  |  7.0000  |  1.0800  |  9.4300  |  1.0700  |  7.0000  |  1.1000  |  9.5000  |  1.0800  |  7.7600  |
     4  |  Brisbane  |  Brisbane International  |  2013-01-01  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |    Istomin D.  |     Klizan M.  |     43  |     30  |   897  |  1175  |   6  |   1  |   6  |   2  |   0  |   0  |   0  |   0  |   0  |   0  |      2  |      0  |  Completed  |  1.9000  |  1.8000  |  1.8700  |  1.8700  |  1.9100  |  1.8000  |  1.8800  |  2.0000  |  1.9100  |  1.8000  |  2.0500  |  2.0000  |  1.8800  |  1.8500  |
     5  |  Brisbane  |  Brisbane International  |  2013-01-01  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |    Millman J.  |        Ito T.  |    199  |     79  |   239  |   655  |   6  |   4  |   6  |   1  |   0  |   0  |   0  |   0  |   0  |   0  |      2  |      0  |  Completed  |  1.6100  |  2.2000  |  1.7500  |  2.0000  |  1.7300  |  2.0000  |  1.7000  |  2.2700  |  1.8000  |  1.9100  |  1.8500  |  2.2800  |  1.7100  |  2.0800  |
     6  |  Brisbane  |  Brisbane International  |  2013-01-01  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |      Falla A.  |     Levine J.  |     54  |    104  |   809  |   530  |   6  |   1  |   7  |   6  |   0  |   0  |   0  |   0  |   0  |   0  |      2  |      0  |  Completed  |  2.2000  |  1.6100  |  2.0800  |  1.6700  |  1.9100  |  1.8000  |  2.2600  |  1.7000  |  2.0000  |  1.7300  |  2.3200  |  1.8300  |  2.0800  |  1.7000  |
     7  |  Brisbane  |  Brisbane International  |  2013-01-01  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |     Melzer J.  |      Kudla D.  |     29  |    137  |  1177  |   402  |   2  |   6  |   6  |   4  |   6  |   4  |   0  |   0  |   0  |   0  |      2  |      1  |  Completed  |  1.4400  |  2.6200  |  1.5500  |  2.3500  |  1.4400  |  2.6200  |  1.6000  |  2.4700  |  1.5000  |  2.5000  |  1.6300  |  2.8200  |  1.5200  |  2.4600  |
     8  |  Brisbane  |  Brisbane International  |  2013-01-01  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |    Robredo T.  |   Harrison R.  |    114  |     69  |   495  |   710  |   6  |   4  |   7  |   6  |   0  |   0  |   0  |   0  |   0  |   0  |      2  |      0  |  Completed  |  3.0000  |  1.3600  |  2.5000  |  1.5000  |  2.3800  |  1.5300  |  2.9300  |  1.4500  |  2.5000  |  1.5000  |  3.2500  |  1.5300  |  2.6600  |  1.4700  |
     9  |  Brisbane  |  Brisbane International  |  2013-01-01  |  ATP250  |  Outdoor  |     Hard  |  1st Round  |        3  |   Dimitrov G.  |      Baker B.  |     48  |     61  |   866  |   756  |   6  |   3  |   7  |   6  |   0  |   0  |   0  |   0  |   0  |   0  |      2  |      0  |  Completed  |  1.3600  |  3.0000  |  1.4000  |  2.8000  |  1.4400  |  2.6200  |  1.3800  |  3.3000  |  1.4000  |  2.7500  |  1.4500  |  3.5500  |  1.3900  |  2.8700  |Groups for depth 0...
</pre></div>

<h4 id="grouping-rows">Grouping Rows</h4>
<p>Two <code>groupBy()</code> methods exist on the <code>DataFrameAxis</code> interface which can be accessed by calling <code>DataFrame.rows()</code> as 
shown below. The first <code>groupBy()</code> function takes one or more column keys from which to extract data to generate the
relavant groups, and the second takes a lambda expression which must return a <code>Tuple</code> representing the group for the 
row presented to it. The following code groups the frame by <code>Surface</code> and then by <code>Round</code>:</p>
<?prettify?>

<pre><code class="java">DataFrame&lt;Integer,String&gt; frame = loadTennisMatchData(2013);
DataFrameGrouping.Rows&lt;Integer,String&gt; grouping = frame.rows().groupBy(&quot;Surface&quot;, &quot;Round&quot;);
</code></pre>

<p>The same grouping can be achieved using the lambda <code>groupBy()</code> method, albeit more verbosely, as follows:</p>
<?prettify?>

<pre><code class="java">DataFrame&lt;Integer,String&gt; frame = loadTennisMatchData(2013);
DataFrameGrouping.Rows&lt;Integer,String&gt; grouping = frame.rows().groupBy(row -&gt; {
    String surface = row.getValue(&quot;Surface&quot;);
    String round = row.getValue(&quot;Round&quot;);
    return Tuple.of(surface, round);
});
</code></pre>

<p>This second example demonstrates to some degree what is going on under the hood in the first example, where
a <code>Tuple</code> that is used to represent the group key is explicitly created in user code. This latter method is useful 
because it allows for an arbitrary group to be created based on data that may not be present in the <code>DataFrame</code>. 
Consider the scenario below where we group the ATP tournament data into months by extracting the month from the 
tournament date as follows:</p>
<?prettify?>

<pre><code class="java">DataFrame&lt;Integer,String&gt; frame = loadTennisMatchData(2013);
frame.rows().groupBy(row -&gt; {
    LocalDate date = row.getValue(&quot;Date&quot;);
    Month month = date.getMonth();
    return Tuple.of(month);
}).forEach(0, (groupKey, group) -&gt; {
    System.out.printf(&quot;There are %s rows for group %s\n&quot;, group.rowCount(), groupKey);
});
</code></pre>

<pre><code>There are 252 rows for group (JANUARY)
There are 332 rows for group (FEBRUARY)
There are 206 rows for group (MARCH)
There are 207 rows for group (APRIL)
There are 298 rows for group (MAY)
There are 275 rows for group (JUNE)
There are 303 rows for group (JULY)
There are 286 rows for group (AUGUST)
There are 136 rows for group (SEPTEMBER)
There are 300 rows for group (OCTOBER)
There are 22 rows for group (NOVEMBER)
There are 14 rows for group (DECEMBER)
</code></pre>
<h5 id="grouping-depth">Grouping Depth</h5>
<p>The <code>DataFrameGrouping</code> interface, an instance of which is returned from the <code>groupBy()</code> methods, provides a versatile
API to query and analyze the grouped data. The previous example demonstrates how to iterate over groups at a given
depth using a user provided lambda <code>BiConsumer</code>. The depth equals the number of dimensions in the grouping, so in the
examples where we perform a 2-dimensional group-by, the depth equals 2.  The Morpheus API allows groups at different
depths to be analyzed independently for maximum versatility. For example, consider a 3-dimensional group-by first by
<code>Court</code>, <code>Surface</code> and then <code>Round</code> as follows:</p>
<?prettify?>

<pre><code class="java">DataFrame&lt;Integer,String&gt; frame = loadTennisMatchData(2013);
DataFrameGrouping.Rows&lt;Integer,String&gt; grouping = frame.rows().groupBy(&quot;Court&quot;, &quot;Surface&quot;, &quot;Round&quot;);
for (int depth=0; depth&lt;grouping.getDepth(); ++depth) {
    System.out.printf(&quot;Groups for depth %s...\n&quot;, depth);
    grouping.getGroupKeys(depth).sorted().forEach(groupKey -&gt; {
        DataFrame&lt;Integer,String&gt; group = grouping.getGroup(groupKey);
        System.out.printf(&quot;There are %s rows for group %s\n&quot;, group.rowCount(), groupKey);
    });
}
</code></pre>

<pre><code>Groups for depth 0...
There are 514 rows for group (Indoor)
There are 2117 rows for group (Outdoor)
Groups for depth 1...
There are 27 rows for group (Indoor,Clay)
There are 487 rows for group (Indoor,Hard)
There are 826 rows for group (Outdoor,Clay)
There are 298 rows for group (Outdoor,Grass)
There are 993 rows for group (Outdoor,Hard)
Groups for depth 2...
There are 12 rows for group (Indoor,Clay,1st Round)
There are 8 rows for group (Indoor,Clay,2nd Round)
There are 4 rows for group (Indoor,Clay,Quarterfinals)
There are 2 rows for group (Indoor,Clay,Semifinals)
There are 1 rows for group (Indoor,Clay,The Final)
There are 216 rows for group (Indoor,Hard,1st Round)
There are 136 rows for group (Indoor,Hard,2nd Round)
There are 8 rows for group (Indoor,Hard,3rd Round)
There are 64 rows for group (Indoor,Hard,Quarterfinals)
There are 12 rows for group (Indoor,Hard,Round Robin)
There are 34 rows for group (Indoor,Hard,Semifinals)
There are 17 rows for group (Indoor,Hard,The Final)
There are 368 rows for group (Outdoor,Clay,1st Round)
There are 240 rows for group (Outdoor,Clay,2nd Round)
There are 56 rows for group (Outdoor,Clay,3rd Round)
There are 8 rows for group (Outdoor,Clay,4th Round)
There are 88 rows for group (Outdoor,Clay,Quarterfinals)
There are 44 rows for group (Outdoor,Clay,Semifinals)
There are 22 rows for group (Outdoor,Clay,The Final)
There are 144 rows for group (Outdoor,Grass,1st Round)
There are 80 rows for group (Outdoor,Grass,2nd Round)
There are 24 rows for group (Outdoor,Grass,3rd Round)
There are 8 rows for group (Outdoor,Grass,4th Round)
There are 24 rows for group (Outdoor,Grass,Quarterfinals)
There are 12 rows for group (Outdoor,Grass,Semifinals)
There are 6 rows for group (Outdoor,Grass,The Final)
There are 436 rows for group (Outdoor,Hard,1st Round)
There are 288 rows for group (Outdoor,Hard,2nd Round)
There are 104 rows for group (Outdoor,Hard,3rd Round)
There are 32 rows for group (Outdoor,Hard,4th Round)
There are 76 rows for group (Outdoor,Hard,Quarterfinals)
There are 38 rows for group (Outdoor,Hard,Semifinals)
There are 19 rows for group (Outdoor,Hard,The Final)
</code></pre>
<h5 id="summary-statistics">Summary Statistics</h5>
<p>The primary motivation for grouping data is very often for aggregation purposes or for computing summary statistics
on the groups. The <code>stats()</code> method on the <code>DataFrameGrouping</code> interface takes the grouping depth to operate on and 
returns a standard Morpheus <code>Stats</code> reference that itself produces <code>DataFrames</code> of summary statistics. The stats frames 
will only include numeric columns on which stats can be calculated. The examples below illustrate the results of computing 
the <code>mean()</code> on groups at different depths. </p>
<?prettify?>

<pre><code class="java">DataFrame&lt;Integer,String&gt; frame = loadTennisMatchData(2013);
DataFrameGrouping.Rows&lt;Integer,String&gt; grouping = frame.rows().groupBy(&quot;Court&quot;, &quot;Surface&quot;, &quot;Round&quot;);
//Computes means for top level groups
grouping.stats(0).mean().rows().sort(true).out().print(formats -&gt; {
    formats.withDecimalFormat(Double.class, &quot;0.00;-0.00&quot;, 1);
});
</code></pre>

<div class="frame"><pre class="frame">
   Index    |  Best of  |  WRank  |  LRank  |   WPts    |   LPts    |   W1   |   L1   |   W2   |   L2   |   W3   |   L3   |   W4   |   L4   |   W5   |   L5   |  Wsets  |  Lsets  |  B365W  |  B365L  |  EXW   |  EXL   |  LBW   |  LBL   |  PSW   |  PSL   |  SJW   |  SJL   |  MaxW  |  MaxL  |  AvgW  |  AvgL  |
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  (Indoor)  |     3.00  |  55.80  |  89.98  |  1908.29  |  1163.28  |  5.79  |  4.14  |  5.67  |  3.91  |  2.16  |  1.19  |  0.00  |  0.00  |  0.00  |  0.00  |   1.94  |   0.36  |   1.90  |   3.26  |  1.86  |  2.95  |  1.86  |  2.94  |  1.99  |  3.39  |  1.88  |  2.99  |  2.09  |  3.66  |  1.90  |  3.07  |
 (Outdoor)  |     3.48  |  52.63  |  84.87  |  2147.69  |  1144.18  |  5.76  |  4.00  |  5.65  |  3.80  |  3.01  |  1.78  |  0.61  |  0.43  |  0.30  |  0.18  |   2.18  |   0.42  |   1.85  |   4.39  |  1.79  |  3.58  |  1.80  |  3.76  |  1.93  |  4.71  |  1.82  |  3.78  |  2.04  |  5.30  |  1.83  |  3.94  |
</pre></div>

<p>Extending this to groups one level below the top level, so therefore with depth = 1:</p>
<?prettify?>

<pre><code class="java">//Computes means for second level, with depth = 1
grouping.stats(1).mean().rows().sort(true).out().print(formats -&gt; {
    formats.withDecimalFormat(Double.class, &quot;0.00;-0.00&quot;, 1);
});
</code></pre>

<div class="frame"><pre class="frame">
      Index       |  Best of  |  WRank  |  LRank  |   WPts    |   LPts    |   W1   |   L1   |   W2   |   L2   |   W3   |   L3   |   W4   |   L4   |   W5   |   L5   |  Wsets  |  Lsets  |  B365W  |  B365L  |  EXW   |  EXL   |  LBW   |  LBL   |  PSW   |  PSL   |  SJW   |  SJL   |  MaxW  |  MaxL  |  AvgW  |  AvgL  |
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   (Indoor,Clay)  |     3.00  |  74.67  |  91.37  |  1411.93  |   785.89  |  6.22  |  4.30  |  5.37  |  4.33  |  2.26  |  1.30  |  0.00  |  0.00  |  0.00  |  0.00  |   1.93  |   0.37  |   1.96  |   3.47  |  1.93  |  3.16  |  1.91  |  3.14  |  2.10  |  3.65  |  1.89  |  3.13  |  2.13  |  3.93  |  1.94  |  3.28  |
   (Indoor,Hard)  |     3.00  |  54.76  |  89.91  |  1935.81  |  1184.21  |  5.77  |  4.13  |  5.69  |  3.89  |  2.16  |  1.18  |  0.00  |  0.00  |  0.00  |  0.00  |   1.94  |   0.36  |   1.90  |   3.25  |  1.86  |  2.94  |  1.85  |  2.93  |  1.99  |  3.37  |  1.88  |  2.98  |  2.09  |  3.65  |  1.90  |  3.06  |
  (Outdoor,Clay)  |     3.31  |  55.96  |  92.25  |  1824.49  |  1091.88  |  5.73  |  3.88  |  5.62  |  3.75  |  2.74  |  1.51  |  0.35  |  0.26  |  0.20  |  0.13  |   2.10  |   0.40  |   1.84  |   4.15  |  1.80  |  3.48  |  1.80  |  3.58  |  1.91  |  4.37  |  1.82  |  3.58  |  2.02  |  4.86  |  1.83  |  3.75  |
 (Outdoor,Grass)  |     3.85  |  63.94  |  95.93  |  1898.03  |  1016.78  |  5.85  |  4.08  |  5.85  |  3.96  |  3.62  |  2.39  |  0.88  |  0.58  |  0.37  |  0.22  |   2.35  |   0.40  |   1.98  |   4.36  |  1.89  |  3.72  |  1.93  |  3.80  |  2.11  |  4.73  |  1.89  |  3.74  |  2.31  |  5.34  |  1.93  |  3.97  |
  (Outdoor,Hard)  |     3.51  |  46.47  |  75.41  |  2491.45  |  1225.92  |  5.76  |  4.08  |  5.61  |  3.81  |  3.05  |  1.83  |  0.74  |  0.52  |  0.37  |  0.21  |   2.19  |   0.45  |   1.81  |   4.61  |  1.76  |  3.62  |  1.77  |  3.90  |  1.89  |  4.98  |  1.80  |  3.95  |  1.98  |  5.65  |  1.80  |  4.08  |
</pre></div>

<p>Finally the most granular grouping can be accessed with depth = 2:</p>
<?prettify?>

<pre><code class="java">//Computes means for third level, with depth = 2
grouping.stats(2).mean().rows().sort(true).out().print(formats -&gt; {
    formats.withDecimalFormat(Double.class, &quot;0.00;-0.00&quot;, 1);
});

</code></pre>

<div class="frame"><pre class="frame">
            Index             |  Best of  |  WRank  |  LRank   |   WPts    |   LPts    |   W1   |   L1   |   W2   |   L2   |   W3   |   L3   |   W4   |   L4   |   W5   |   L5   |  Wsets  |  Lsets  |  B365W  |  B365L  |  EXW   |  EXL   |  LBW   |  LBL   |  PSW   |  PSL   |  SJW   |  SJL   |  MaxW  |  MaxL  |  AvgW  |  AvgL  |
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     (Indoor,Clay,1st Round)  |     3.00  |  88.50  |  112.83  |   630.58  |   613.67  |  6.33  |  4.42  |  4.83  |  4.42  |  2.42  |  1.33  |  0.00  |  0.00  |  0.00  |  0.00  |   1.83  |   0.42  |   1.95  |   2.55  |  1.92  |  2.55  |  1.89  |  2.46  |  2.04  |  2.69  |  1.89  |  2.43  |  2.05  |  2.93  |  1.90  |  2.58  |
     (Indoor,Clay,2nd Round)  |     3.00  |  70.25  |   69.50  |  1458.88  |   966.75  |  6.38  |  4.25  |  5.75  |  3.62  |  1.63  |  1.00  |  0.00  |  0.00  |  0.00  |  0.00  |   2.00  |   0.25  |   2.09  |   4.22  |  2.05  |  3.48  |  2.04  |  3.38  |  2.33  |  4.38  |  1.98  |  3.05  |  2.38  |  4.69  |  2.09  |  3.76  |
 (Indoor,Clay,Quarterfinals)  |     3.00  |  72.25  |   68.25  |  1808.50  |  1109.25  |  5.75  |  5.25  |  5.50  |  5.00  |  3.25  |  2.50  |  0.00  |  0.00  |  0.00  |  0.00  |   2.00  |   0.50  |   2.22  |   3.48  |  2.13  |  3.23  |  2.15  |  3.50  |  2.33  |  3.26  |  2.12  |  3.49  |  2.37  |  3.70  |  2.17  |  3.24  |
    (Indoor,Clay,Semifinals)  |     3.00  |  49.00  |   95.50  |  3050.00  |   567.00  |  6.00  |  3.00  |  6.50  |  6.00  |  3.00  |  0.50  |  0.00  |  0.00  |  0.00  |  0.00  |   2.00  |   0.50  |   1.28  |   6.25  |  1.31  |  5.18  |  1.29  |  5.44  |  1.35  |  7.23  |  1.28  |  6.75  |  1.35  |  7.82  |  1.30  |  5.94  |
     (Indoor,Clay,The Final)  |     3.00  |   5.00  |   93.00  |  5550.00  |   550.00  |  6.00  |  2.00  |  6.00  |  3.00  |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |   2.00  |   0.00  |   1.44  |   2.75  |  1.38  |  2.90  |  1.40  |  2.75  |  1.52  |  2.78  |  1.44  |  2.75  |  1.57  |  2.90  |  1.44  |  2.73  |
     (Indoor,Hard,1st Round)  |     3.00  |  78.47  |  119.85  |   983.54  |   791.82  |  5.74  |  4.19  |  5.80  |  3.74  |  1.89  |  1.06  |  0.00  |  0.00  |  0.00  |  0.00  |   1.92  |   0.32  |   2.06  |   3.05  |  2.00  |  2.72  |  1.97  |  2.70  |  2.16  |  3.15  |  2.01  |  2.73  |  2.30  |  3.38  |  2.07  |  2.85  |
     (Indoor,Hard,2nd Round)  |     3.00  |  47.49  |   85.58  |  1933.18  |   876.24  |  5.86  |  3.90  |  5.66  |  4.09  |  2.14  |  1.20  |  0.00  |  0.00  |  0.00  |  0.00  |   1.96  |   0.35  |   1.76  |   3.51  |  1.75  |  3.18  |  1.75  |  3.16  |  1.83  |  3.58  |  1.76  |  3.26  |  1.91  |  4.02  |  1.76  |  3.31  |
     (Indoor,Hard,3rd Round)  |     3.00  |   5.25  |   16.88  |  6193.75  |  2036.25  |  5.88  |  4.38  |  6.00  |  2.88  |  1.50  |  0.75  |  0.00  |  0.00  |  0.00  |  0.00  |   2.00  |   0.25  |   1.37  |   3.57  |  1.41  |  3.32  |  1.42  |  3.38  |  1.44  |  3.85  |  1.42  |  3.28  |  1.47  |  4.00  |  1.41  |  3.37  |
 (Indoor,Hard,Quarterfinals)  |     3.00  |  32.70  |   66.11  |  2366.33  |  1487.16  |  5.87  |  4.25  |  5.44  |  3.89  |  2.41  |  1.28  |  0.00  |  0.00  |  0.00  |  0.00  |   1.92  |   0.39  |   1.89  |   3.23  |  1.81  |  2.99  |  1.84  |  2.95  |  1.98  |  3.49  |  1.87  |  3.01  |  2.09  |  3.67  |  1.87  |  3.05  |
   (Indoor,Hard,Round Robin)  |     3.00  |   4.17  |    6.08  |  7602.08  |  4375.42  |  6.00  |  4.75  |  5.33  |  5.00  |  4.17  |  2.08  |  0.00  |  0.00  |  0.00  |  0.00  |   2.00  |   0.67  |   1.44  |   4.03  |  1.44  |  3.75  |  1.44  |  3.98  |  1.49  |  4.08  |  1.45  |  3.87  |  1.53  |  4.30  |  1.45  |  3.81  |
</pre></div>

<h4 id="grouping-columns">Grouping Columns</h4>
<p>Grouping columns in a <code>DataFrame</code> is entirely analogous to grouping rows as the API is completely symmetrical in the
row and column dimension. Instead of operating on the <code>DataFrameAxis</code> returned by a call to <code>DataFrame.rows()</code>, you operate 
on the same interface returned from <code>DataFrame.cols()</code>. The ATP match results served as a good candidate for grouping rows, 
but is not appropriate for grouping columns as there are few if any repetitions within a given row. Rather than introduce 
a new dataset, we can simply transpose the ATP dataset and then group the columns.</p>
<?prettify?>

<pre><code class="java">//Transpose the ATP match data, select 20 left columns, print first ten rows
loadTennisMatchData(2013).transpose().left(20).out().print(10);
</code></pre>

<div class="frame"><pre class="frame">
   Index     |            0             |            1             |            2             |            3             |            4             |            5             |            6             |            7             |            8             |            9             |            10            |            11            |            12            |            13            |            14            |            15            |            16            |            17            |            18            |            19            |
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Location  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |                Brisbane  |
 Tournament  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |  Brisbane International  |
       Date  |              2012-12-31  |              2012-12-31  |              2012-12-31  |              2012-12-31  |              2013-01-01  |              2013-01-01  |              2013-01-01  |              2013-01-01  |              2013-01-01  |              2013-01-01  |              2013-01-01  |              2013-01-01  |              2013-01-02  |              2013-01-02  |              2013-01-02  |              2013-01-02  |              2013-01-03  |              2013-01-03  |              2013-01-03  |              2013-01-03  |
     Series  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |                  ATP250  |
      Court  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |                 Outdoor  |
    Surface  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |                    Hard  |
      Round  |               1st Round  |               1st Round  |               1st Round  |               1st Round  |               1st Round  |               1st Round  |               1st Round  |               1st Round  |               1st Round  |               1st Round  |               1st Round  |               1st Round  |               2nd Round  |               2nd Round  |               2nd Round  |               2nd Round  |               2nd Round  |               2nd Round  |               2nd Round  |               2nd Round  |
    Best of  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |                       3  |
     Winner  |                Mayer F.  |             Nieminen J.  |            Nishikori K.  |            Baghdatis M.  |              Istomin D.  |              Millman J.  |                Falla A.  |               Melzer J.  |              Robredo T.  |             Dimitrov G.  |               Goffin D.  |               Hewitt L.  |                Simon G.  |            Baghdatis M.  |            Nishikori K.  |           Dolgopolov O.  |             Dimitrov G.  |               Melzer J.  |              Istomin D.  |               Murray A.  |
      Loser  |              Giraldo S.  |            Benneteau J.  |            Matosevic M.  |             Mitchell B.  |               Klizan M.  |                  Ito T.  |               Levine J.  |                Kudla D.  |             Harrison R.  |                Baker B.  |                Ebden M.  |             Kunitsyn I.  |                Falla A.  |                Mayer F.  |              Robredo T.  |             Nieminen J.  |               Raonic M.  |               Goffin D.  |               Hewitt L.  |              Millman J.  |Groups for depth 0...
</pre></div>

<p>With the transposed ATP match results <code>DataFrame</code>, we can now group the columns in much the same way as we grouped the 
rows. The code below performs a 2-dimensional column grouping based on data in the rows identified by <code>Court</code> and <code>Surface</code>,
and subsequently prints out the number of columns per group at level 0 and 1.</p>
<?prettify?>

<pre><code class="java">DataFrame&lt;String,Integer&gt; frame = loadTennisMatchData(2013).transpose();
DataFrameGrouping.Cols&lt;String,Integer&gt; grouping = frame.cols().groupBy(&quot;Court&quot;, &quot;Surface&quot;);
for (int depth=0; depth&lt;grouping.getDepth(); ++depth) {
    System.out.printf(&quot;Groups for depth %s...\n&quot;, depth);
    grouping.getGroupKeys(depth).sorted().forEach(groupKey -&gt; {
        DataFrame&lt;String,Integer&gt; group = grouping.getGroup(groupKey);
        System.out.printf(&quot;There are %s columns for group %s\n&quot;, group.colCount(), groupKey);
    });
}
</code></pre>

<pre><code>Groups for depth 0...
There are 514 columns for group (Indoor)
There are 2117 columns for group (Outdoor)
Groups for depth 1...
There are 27 columns for group (Indoor,Clay)
There are 487 columns for group (Indoor,Hard)
There are 826 columns for group (Outdoor,Clay)
There are 298 columns for group (Outdoor,Grass)
There are 993 columns for group (Outdoor,Hard)
</code></pre>
<p>To avoid repetition, further column grouping examples are omitted as they are identical to the row grouping scenarios 
illustrated in prior sections. The next section presents and discusses some data on grouping performance of large 
<code>DataFrames</code>.</p>
<h4 id="performance">Performance</h4>
<p>The performance of the group-by functions on a <code>DataFrame</code> will vary depending on many factors, including 
but not limited to the number of resulting groups, the depth of the grouping and the cost of extracting the 
relevant data from rows or columns. As with many <code>DataFrame</code> operations, a <strong>parallel</strong> implementation of grouping 
can be used to speed up scenarios which involve a large number of records and/or ones in which the code to 
assemble a group is somewhat costly. This section provides examples of how sequential and parallel grouping 
performance might be expected to compare in the most common scenarios. The absolute times published below are 
obviously vary machine specific, and in this case relate to a Macbook Pro with Quad Core-i7 processor.</p>
<h5 id="example-data_1">Example Data</h5>
<p>The ATP match data only holds a few thousand records per year which is a little small to gather reasonable group-by 
performance statistics against (the times will be small and thus sensitive to measurement noise). We will therefore 
use the the UK house price transaction data made available from the UK Land Registry as introduced in the Morpeus 
Overview section. This dataset, which contains approximately 1.35 records in 2006, can be loaded using the code below. 
While the raw data is in CSV format, it does not include a header as the first row, so for convenience we map the 
default numbered columns to more meaningful names.</p>
<?prettify?>

<pre><code class="java">/**
 * Returns a DataFrame of UK house prices from the Land Registry of the UK
 * @param year      the year to load prices for
 * @return          the house price DataFrame
 */
static DataFrame&lt;Integer,String&gt; loadHousePrices(int year) {
    return DataFrame.read().csv(options -&gt; {
        options.setHeader(false);
        options.setParallel(true);
        options.setExcludeColumns(&quot;Column-0&quot;);
        options.setResource(&quot;/uk-house-prices-&quot; + year + &quot;.csv&quot;);
        options.getFormats().setDateFormat(&quot;Date&quot;, &quot;yyyy-MM-dd HH:mm&quot;);
        options.setColumnNameMapping((colName, colOrdinal) -&gt; {
            switch (colOrdinal) {
                case 0:  return &quot;Price&quot;;
                case 1:  return &quot;Date&quot;;
                case 2:  return &quot;PostCode&quot;;
                case 3:  return &quot;PropertyType&quot;;
                case 4:  return &quot;Old/New&quot;;
                case 5:  return &quot;Duration&quot;;
                case 6:  return &quot;PAON&quot;;
                case 7:  return &quot;SAON&quot;;
                case 8:  return &quot;Street&quot;;
                case 9:  return &quot;Locality&quot;;
                case 10: return &quot;Town/City&quot;;
                case 11: return &quot;District&quot;;
                case 12: return &quot;County&quot;;
                case 13: return &quot;PPDType&quot;;
                case 14: return &quot;RecordStatus&quot;;
                default: return colName;
            }
        });
    });
}
</code></pre>

<div class="frame"><pre class="frame">
 Index  |  Price   |         Date          |  PostCode  |  PropertyType  |  Old/New  |  Duration  |  PAON  |  SAON  |        Street        |   Locality   |  Town/City   |       District       |        County        |  PPDType  |  RecordStatus  |
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     0  |  180000  |  2006-06-30T00:00:00  |   PR2 3SP  |             S  |        N  |         F  |    30  |  null  |    CLEVELEYS AVENUE  |     FULWOOD  |     PRESTON  |             PRESTON  |          LANCASHIRE  |        A  |             A  |
     1  |   99750  |  2006-09-15T00:00:00  |  EX23 8TA  |             F  |        N  |         L  |    25  |  null  |         BULLEID WAY  |        BUDE  |        BUDE  |      NORTH CORNWALL  |            CORNWALL  |        A  |             A  |
     2  |   65000  |  2006-10-06T00:00:00  |  BB12 7ER  |             T  |        N  |         L  |    70  |  null  |  SHAKESPEARE STREET  |     PADIHAM  |     BURNLEY  |             BURNLEY  |          LANCASHIRE  |        A  |             A  |
     3  |  120000  |  2006-02-13T00:00:00  |   LE2 1PB  |             T  |        N  |         F  |    35  |  null  |       CHEPSTOW ROAD  |   LEICESTER  |   LEICESTER  |           LEICESTER  |           LEICESTER  |        A  |             A  |
     4  |  112000  |  2006-04-07T00:00:00  |  CF38 2JF  |             T  |        N  |         F  |   127  |  null  |         MANOR CHASE  |      BEDDAU  |  PONTYPRIDD  |  RHONDDA CYNON TAFF  |  RHONDDA CYNON TAFF  |        A  |             A  |
     5  |   84950  |  2006-02-24T00:00:00  |   CV6 4AS  |             T  |        N  |         F  |   381  |  null  |        BURNABY ROAD  |        null  |    COVENTRY  |            COVENTRY  |       WEST MIDLANDS  |        A  |             A  |
     6  |  124950  |  2006-10-06T00:00:00  |  ST20 0HZ  |             S  |        N  |         F  |    38  |  null  |     ST LAWRENCE WAY  |     GNOSALL  |    STAFFORD  |            STAFFORD  |       STAFFORDSHIRE  |        A  |             A  |
     7  |   30000  |  2006-11-03T00:00:00  |    M8 0QL  |             S  |        Y  |         F  |    32  |  null  |          CHIME BANK  |  MANCHESTER  |  MANCHESTER  |          MANCHESTER  |  GREATER MANCHESTER  |        A  |             A  |
     8  |  380000  |  2006-09-25T00:00:00  |    N7 9SY  |             F  |        N  |         F  |     8  |  null  |    HEDDINGTON GROVE  |      LONDON  |      LONDON  |           ISLINGTON  |      GREATER LONDON  |        A  |             A  |
     9  |  451000  |  2006-02-08T00:00:00  |   SW9 9AL  |             F  |        Y  |         L  |    29  |  null  |         STANE GROVE  |        null  |      LONDON  |             LAMBETH  |      GREATER LONDON  |        A  |             A  |
</pre></div>

<h5 id="group-count">Group Count</h5>
<p>The first example attempts to demonstrate the performance impact of an increasing number of groups created by a the 
group-by operation. In this case we group the rows of the UK property transaction data for 2006 by 5 different columns 
independently, namely <code>PropertyType</code>, <code>County</code>, <code>Month</code>, <code>District</code>, <code>Town/City</code> and <code>Locality</code>. The group count for these 
columns is listed below. The expectation is that execution times will increase as the number of groups generated by a group-by 
function increases, which is exactly what we see in the subsequent plot.</p>
<ul>
<li><strong>Property Type</strong>: 5 Groups</li>
<li><strong>Month</strong>: 12 Groups</li>
<li><strong>County</strong>: 115 Groups</li>
<li><strong>District</strong>: 387 Groups</li>
<li><strong>Town/City</strong>: 1161 Groups</li>
<li><strong>Locality</strong>: 16800 Groups</li>
</ul>
<p align="center">
    <img class="chart" src="../../images/frame/data-frame-group-by-0.png"/>
</p>

<p>Running this same example with <strong>parallel execution</strong> yields a similar trend, but the absolute times are much smaller.</p>
<p align="center">
    <img class="chart" src="../../images/frame/data-frame-group-by-1.png"/>
</p>

<p>The following code is used to generate the above results, for the sequential execution.</p>
<?prettify?>

<pre><code class="java">//Load UK house prices for 2006
DataFrame&lt;Integer,String&gt; frame = loadHousePrices(2006);

//Run 10 iterations of sequential and parallel group by Town/City
DataFrame&lt;String,String&gt; results = PerfStat.run(5, TimeUnit.MILLISECONDS, false, tasks -&gt; {
    tasks.put(&quot;PropertyType&quot;, () -&gt; frame.rows().groupBy(&quot;PropertyType&quot;));
    tasks.put(&quot;Month&quot;, () -&gt; frame.rows().groupBy(row -&gt; {
        final LocalDateTime date = row.getValue(&quot;Date&quot;);
        return Tuple.of(date.getMonth());
    }));
    tasks.put(&quot;County&quot;, () -&gt; frame.rows().groupBy(&quot;County&quot;));
    tasks.put(&quot;District&quot;, () -&gt; frame.rows().groupBy(&quot;District&quot;));
    tasks.put(&quot;Town/City&quot;, () -&gt; frame.rows().groupBy(&quot;Town/City&quot;));
    tasks.put(&quot;Locality&quot;, () -&gt; frame.rows().groupBy(&quot;Locality&quot;));
});

//Plot the results of the combined DataFrame with timings
Chart.create().withBarPlot(results, false, chart -&gt; {
    chart.plot().axes().domain().label().withText(&quot;Timing Statistic&quot;);
    chart.plot().axes().range(0).label().withText(&quot;Time In Milliseconds&quot;);
    chart.title().withText(&quot;1-Dimensional Grouping of 1.35 Million Rows (Sequential)&quot;);
    chart.title().withFont(new Font(&quot;Verdana&quot;, Font.PLAIN, 15));
    chart.subtitle().withText(&quot;Grouping of UK House Price Transactions in 2006 by various columns&quot;);
    chart.legend().on().bottom();
    chart.show();
});
</code></pre>

<h5 id="sequential-vs-parallel">Sequential vs Parallel</h5>
<p>The following example plots the results of a standard 1-dimensional group-by operation on the same chart. The 1.35 
million rows in the UK house price dataset is grouped by <code>County</code>, which results in 115 distinct groups as indicated
in the previous section. The timing statistics below seem to indicate the parallel grouping in this scenario was a little
over twice as fast as the sequential algorithm. This result bodes well as this is the simplest possible group-by scenatio, 
and we would expect the parallel algorithm to perform even better as the grouping complexity increases.</p>
<p align="center">
    <img class="chart" src="../../images/frame/data-frame-group-by-2.png"/>
</p>

<p>The following code is used to generate the above results.</p>
<?prettify?>

<pre><code class="java">//Load UK house prices for 2006
DataFrame&lt;Integer,String&gt; frame = loadHousePrices(2006);

//Run 10 iterations of sequential and parallel group by County
DataFrame&lt;String,String&gt; results = PerfStat.run(10, TimeUnit.MILLISECONDS, false, tasks -&gt; {
    tasks.put(&quot;Sequential&quot;, () -&gt; frame.rows().sequential().groupBy(&quot;County&quot;));
    tasks.put(&quot;Parallel&quot;, () -&gt; frame.rows().parallel().groupBy(&quot;County&quot;));
});

//Plot the results of the combined DataFrame with timings
Chart.create().withBarPlot(results, false, chart -&gt; {
    chart.plot().axes().domain().label().withText(&quot;Timing Statistic&quot;);
    chart.plot().axes().range(0).label().withText(&quot;Time In Milliseconds&quot;);
    chart.title().withText(&quot;1-Dimensional Grouping of 1.35 Million Rows&quot;);
    chart.title().withFont(new Font(&quot;Verdana&quot;, Font.PLAIN, 15));
    chart.subtitle().withText(&quot;Grouping of UK House Price Transactions in 2006 by County&quot;);
    chart.legend().on().bottom();
    chart.show();
});
</code></pre>

<h5 id="multi-dimensional">Multi-Dimensional</h5>
<p>The prior examples use 1-dimensional grouping only, so this section looks at the cost of a multi-dimensioal
group-by on the rows of the UK property transaction data. In order to remove group count as a factor in the second
dimension, we simply group by the same column twice. This is not particularly useful in reality other than to assess 
the relative cost of adding the second dimension. Naturally, the group count in the second dimension will always
be 1.</p>
<p>The plot below indicates adding another dimension is significant, although using parallel execution can mostly
discount the additional cost, at least in this scenario.</p>
<p align="center">
    <img class="chart" src="../../images/frame/data-frame-group-by-3.png"/>
</p>

<p>The following code is used to generate the above results.</p>
<?prettify?>

<pre><code class="java">//Load UK house prices for 2006
DataFrame&lt;Integer,String&gt; frame = loadHousePrices(2006);

//Run 10 iterations of sequential and parallel group by County and Town/City
DataFrame&lt;String,String&gt; results = PerfStat.run(10, TimeUnit.MILLISECONDS, false, tasks -&gt; {
    tasks.put(&quot;Sequential(1-D)&quot;, () -&gt; frame.rows().sequential().groupBy(&quot;County&quot;));
    tasks.put(&quot;Parallel(1-D)&quot;, () -&gt; frame.rows().parallel().groupBy(&quot;County&quot;));
    tasks.put(&quot;Sequential(2-D)&quot;, () -&gt; frame.rows().sequential().groupBy(&quot;County&quot;, &quot;County&quot;));
    tasks.put(&quot;Parallel(2-D)&quot;, () -&gt; frame.rows().parallel().groupBy(&quot;County&quot;, &quot;County&quot;));
});

//Plot the results of the combined DataFrame with timings
Chart.create().withBarPlot(results, false, chart -&gt; {
    chart.plot().axes().domain().label().withText(&quot;Timing Statistic&quot;);
    chart.plot().axes().range(0).label().withText(&quot;Time In Milliseconds&quot;);
    chart.title().withText(&quot;1-Dimension vs 2-Dimensional Grouping of 1.35 Million Rows&quot;);
    chart.title().withFont(new Font(&quot;Verdana&quot;, Font.PLAIN, 15));
    chart.subtitle().withText(&quot;Grouping of UK House Price Transactions in 2006 by County x 2&quot;);
    chart.legend().on().bottom();
    chart.show();
});
</code></pre>

<h5 id="grouping-function">Grouping Function</h5>
<p>The Morpheus API provides two styles of grouping function, the first simply takes the column keys or row
keys depending if you are grouping rows or columns respectively. The second style uses a lambda expression
that consumes either the row or column, and returns a <code>Tuple</code> that represents the group for that entry. The
latter is more flexible in that it can produce a group that is based on some derived calculation on the
row or column vector it is presented with. This section assess whether there is any perfomance difference
to using either of these approaches.</p>
<p>In this example we perform a two-dimensional group by using the <code>County</code> first, and the <code>Town/City</code> second.
The results in the subsequent plot suggests there is a very small performance cost to using the second style,
however it is fairly neglible in this case.</p>
<p align="center">
    <img class="chart" src="../../images/frame/data-frame-group-by-4.png"/>
</p>

<p>The following code is used to generate the above results.</p>
<?prettify?>

<pre><code class="java">//Load UK house prices for 2006
DataFrame&lt;Integer,String&gt; frame = loadHousePrices(2006);

//Run 10 iterations of sequential and parallel group by County and Town/City
DataFrame&lt;String,String&gt; results = PerfStat.run(5, TimeUnit.MILLISECONDS, false, tasks -&gt; {
    tasks.put(&quot;Method-1&quot;, () -&gt; frame.rows().groupBy(&quot;County&quot;, &quot;Town/City&quot;));
    tasks.put(&quot;Method-2&quot;, () -&gt; frame.rows().groupBy(row -&gt; Tuple.of(
        row.&lt;String&gt;getValue(&quot;County&quot;),
        row.&lt;String&gt;getValue(&quot;Town/City&quot;))
    ));
});

//Plot the results of the combined DataFrame with timings
Chart.create().withBarPlot(results, false, chart -&gt; {
    chart.plot().axes().domain().label().withText(&quot;Timing Statistic&quot;);
    chart.plot().axes().range(0).label().withText(&quot;Time In Milliseconds&quot;);
    chart.title().withText(&quot;2-Dimensional Grouping of 1.35 Million Rows&quot;);
    chart.title().withFont(new Font(&quot;Verdana&quot;, Font.PLAIN, 15));
    chart.subtitle().withText(&quot;Grouping of UK House Price Transactions in 2006 by County &amp; Town/City&quot;);
    chart.legend().on().bottom();
    chart.show();
});
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright (C) 2014-2017 Xavier Witdouck</p>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '../..';</script>
        <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
        <script src="../../js/base.js"></script>
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script src="http://www.zavtech.com/morpheus/docs/javascript/analytics.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
