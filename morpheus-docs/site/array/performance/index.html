<!--
  ~ Copyright (C) 2014-2018 D3X Systems - All Rights Reserved
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~ http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <meta name="author" content="Xavier Witdouck">

        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Performance - Morpheus</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../.././css/morpheus.css" rel="stylesheet">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

	<script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../..">Morpheus</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="../..">Overview</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Array <b class="caret"></b></a>
                        <ul class="dropdown-menu">

<li >
    <a href="../overview/">Overview</a>
</li>

<li class="active">
    <a href="./">Performance</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">DataFrame <b class="caret"></b></a>
                        <ul class="dropdown-menu">

<li >
    <a href="../../frame/construction/">Construction</a>
</li>

<li >
    <a href="../../frame/access/">Accessing</a>
</li>

<li >
    <a href="../../frame/reshaping/">Reshaping</a>
</li>

<li >
    <a href="../../frame/filtering/">Filtering</a>
</li>

<li >
    <a href="../../frame/sorting/">Sorting</a>
</li>

<li >
    <a href="../../frame/grouping/">Grouping</a>
</li>

<li >
    <a href="../../frame/finding/">Finding</a>
</li>

<li >
    <a href="../../frame/writing/">Writing</a>
</li>

<li >
    <a href="../../frame/performance/">Performance</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Analysis <b class="caret"></b></a>
                        <ul class="dropdown-menu">

<li >
    <a href="../../analysis/statistics/">Descriptive Statistics</a>
</li>

  <li class="dropdown-submenu">
    <a href="#">Linear Regression</a>
    <ul class="dropdown-menu">

<li >
    <a href="../../regression/ols/">Ordinary Least Squares</a>
</li>

<li >
    <a href="../../regression/wls/">Weighted Least Squares</a>
</li>

<li >
    <a href="../../regression/gls/">Generalized Least Squares</a>
</li>
    </ul>
  </li>

<li >
    <a href="../../analysis/pca/">Principal Component Analysis</a>
</li>

<li >
    <a href="../../analysis/linearalgebra/">Linear Algebra</a>
</li>

<li >
    <a href="../../analysis/timeseries/">Time Series Analysis</a>
</li>

  <li class="dropdown-submenu">
    <a href="#">Examples</a>
    <ul class="dropdown-menu">

<li >
    <a href="../../examples/mpt/">Modern Portfolio Theory</a>
</li>
    </ul>
  </li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Visualization <b class="caret"></b></a>
                        <ul class="dropdown-menu">

  <li class="dropdown-submenu">
    <a href="#">Charts</a>
    <ul class="dropdown-menu">

<li >
    <a href="../../viz/charts/overview/">Overview</a>
</li>

<li >
    <a href="../../viz/charts/embed/">Embedding (HTML)</a>
</li>

<li >
    <a href="../../viz/charts/gallery1/">Gallery (Google)</a>
</li>

<li >
    <a href="../../viz/charts/gallery2/">Gallery (JFree)</a>
</li>
    </ul>
  </li>

<li >
    <a href="../../viz/tables/overview/">Tables</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Data Sources <b class="caret"></b></a>
                        <ul class="dropdown-menu">

<li >
    <a href="../../providers/quandl/">Quandl</a>
</li>

<li >
    <a href="../../providers/fred/">Federal Reserve</a>
</li>

<li >
    <a href="../../providers/google/">Google Finance</a>
</li>

<li >
    <a href="../../providers/yahoo/">Yahoo Finance</a>
</li>

<li >
    <a href="../../providers/world-bank/">World Bank</a>
</li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../overview/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../../frame/construction/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/zavtech/morpheus-core">
                                <i class="fa fa-github"></i>GitHub
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#introduction">Introduction</a></li>
        <li class="main "><a href="#native-arrays">Native Arrays</a></li>
        <li class="main "><a href="#morpheus-arrays">Morpheus Arrays</a></li>
            <li><a href="#motivation">Motivation</a></li>
            <li><a href="#design-compromise">Design Compromise</a></li>
            <li><a href="#iteration-boxing">Iteration &amp; Boxing</a></li>
            <li><a href="#sorting">Sorting</a></li>
            <li><a href="#summary-statistics">Summary Statistics</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h3 id="introduction">Introduction</h3>
<p>The following sections provide some micro-benchmark timing and memory statistics for various
types of Morpheus <code>Arrays</code>. These benchmarks where performed on a 2013 MacBook Pro with a Core
i7 2.6Ghz Quad-core CPU, and 16GB of memory. As with all benchmarks, these figures should be
taken with a pinch of salt as real-world performance could differ substantially for all sorts
of reasons. They are however a reasonable set of observations to compare the relative cost of
different operations, and also to get a sense of how the sequential versus parallel execution
of these operations compares.</p>
<h3 id="native-arrays">Native Arrays</h3>
<p>Non-primitive Java arrays do not scale particularly well, specifically in terms of their memory
consumption, and more importantly, they put a significant burden on the garbage collector. To
illustrate this point, consider the plots below which compare the average initialization time
(construction and population) of various types of array containing 5 million entries, followed
by the subsequent garbage collection times. The lower case <code>boolean</code>, <code>int</code>, <code>long</code> and <code>double</code>
labels represent primitive array types while the capitalized <code>Boolean</code>, <code>Integer</code>, <code>Long</code> and <code>Double</code>
represent the boxed versions.</p>
<p align="center">
    <img class="chart" src="../../images/native-array-create-times.png"/>
</p>

<p><strong>Figure 1. Expect significant dispersion in initialization times for large non-primitive arrays</strong></p>
<p>While the variation in initialisation times appears to be fairly significant, the <strong>magnitude</strong> of the
garbage collection (GC) times in figure 2 is potentially more concerning. The GC times for
primitive arrays barely registers on this chart which is dominated by the results for <code>ZonedDateTime</code>.
Primitive arrays are represented by a single object and a contiguous block of memory, so the
collector only needs to keep track of one reference when performing its sweep. Clearly this makes
a profound difference in performance.</p>
<p align="center">
    <img class="chart" src="../../images/native-array-gc-times.png"/>
</p>

<p><strong>Figure 2. ZonedDateTime has a great API for time zone aware dates, but it comes at a price</strong></p>
<p>Using the <code>Instrumentation</code> interface introduced in Java 5, we estimate the relative sizes
of these various array instances, and once again, primitive arrays win hands down. Notice how
the <code>Date</code> array consumes more than twice the memory of a primitive <code>long</code> array of the same
length, even though its internal state is no more than a single <code>long</code> field representing epoch
milliseconds. Also, it appears that the boxed versions of the <code>boolean</code>, <code>int</code>, <code>long</code> and <code>double</code>
arrays use at least 3 times more memory.</p>
<p align="center">
    <img class="chart" src="../../images/native-array-memory.png"/>
</p>

<p><strong>Figure 3. The boxed versions of the arrays appear to take more than 2-3 times the memory of their primitive counterparts</strong></p>
<p>There is work underway at Oracle to address some of these issues, however it is not yet clear
which future Java release, if any, will include some of the changes discussed <a href="http://cr.openjdk.java.net/~jrose/pres/201207-Arrays-2.pdf">here</a>.</p>
<hr />
<h3 id="morpheus-arrays">Morpheus Arrays</h3>
<h4 id="motivation">Motivation</h4>
<p>The moral of the story above is that to build high performance systems involving large data,
primitive arrays have to be used wherever possible, which is the fundamental design motivation
behind the Morpheus Array package. </p>
<p>This is by no means an attempt to compete with excellent primitive collections libraries such as
<a href="http://trove.starlight-systems.com/">Trove</a> and <a href="https://github.com/goldmansachs/gs-collections">Goldman Sachs Collections</a>,
and in fact, sparse implementations of Morpheus arrays use the Trove library internally. The
Morpheus Array interface is a much more narrowly focused data structure, whose design was ultimately
motivated by the desire to build an efficient in-memory column store called a <code>DataFrame</code>.</p>
<p>The Morpheus library ships with a number of implementations of the <code>com.d3x.morpheus.array.Array</code>
interface, with support for many commonly used types. Each implementation is designed to unbox an object
into an appropriate primitive representation where possible, and box it when it is being read back from
the array. So for example, <code>Array&lt;Date&gt;</code> internally contains a primitive array of longs which store epoch
millisecond values. <code>Array&lt;String&gt;</code> represents its internal state with a large <code>char</code>array, and unboxes
strings to store their contents at an appropriate location within this large <code>char</code> array. Additional
<code>char</code> arrays are created if the size exceeds Integer.MAX_VALUE.</p>
<h4 id="design-compromise">Design Compromise</h4>
<p>This design choice is obviously a compromise in that it introduces a boxing/unboxing cost when reading
and writing elements against a Morpheus array. While this is true, for the most part it turns out to be
a favorable compromise with more benefits than drawbacks, because it plays to the strengths
of the Java Virtual Machine. Specifically, it is sympathetic to the fundamental design philosophy
of generational garbage collection algorithms, which assume that most objects die young.</p>
<p>The plots below compare the same performance statistics discussed in the previous section in order to get
a sense of how Morpheus arrays compare to their native counterparts. As expected, the first chart suggests
that Morpheus arrays are somewhat slower to initialize, although not alarmingly so. This differential in
performance is not unexpected, even for the cases where no unboxing is required, as a method call
is necessary to set the value unlike the [] operator for native arrays. </p>
<p align="center">
    <img class="chart" src="../../images/native-vs-morpheus-init-times.png"/>
</p>

<p><strong>Figure 4. Morpheus arrays are slightly slower to initialise, but not alarmingly so - there is payback for the effort</strong></p>
<p>There is a huge return on the investment made to keep everything as primitives however, and the subsequent
garbage collection times for Morpheus arrays is a small fraction compared to non-primitive native arrays.
Figure 5 is the same plot as figure 4, but including the subsequent GC times to deallocate the array
created in each test. So while you pay a small performance penalty with respect to initialisation, the
massive reduction in the GC load easily offsets this. Considering the <em>magnitude</em> of the native object
array GC times, it feels like a good trade.</p>
<p align="center">
    <img class="chart" src="../../images/native-vs-morpheus-gc-times.png"/>
</p>

<p><strong>Figure 5. Morpheus arrays which are based on primitives internally, are very friendly to the garbage collector</strong></p>
<p>There is also a material reduction in the amount of memory required to store Morpheus arrays. Notice the huge
drop in memory required to represent a <code>ZonedDateTime</code> array, or at least the equivalent information within a Morpheus
array. Clearly it is not possible to improve on the allocated memory for primitive types, but in these cases
Morpheus arrays match their native counterparts.</p>
<p align="center">
    <img class="chart" src="../../images/native-vs-morpheus-memory.png"/>
</p>

<p><strong>Figure 6. Morpheus arrays use significantly less memory than their object counterparts</strong></p>
<h4 id="iteration-boxing">Iteration &amp; Boxing</h4>
<p>Significantly reduced memory usage and much faster Garbage Collection times in return for slightly slower
initialization appears to be a reasonable compromise. Sadly, that does not fully represent the extent of the
trade-off here, as iteration times on some Morpheus arrays is likely to be slower, at least in cases where
each element access requires boxing. For <code>boolean</code>, <code>int</code>, <code>long</code> and <code>double</code>array types this is obviously
not an issue, but for other types there is likely to be a cost.</p>
<p>The results in figure 7 illustrate this performance deficit for a Morpheus <code>LocalDateTime</code> array versus its
native counterpart. In both sequential and parallel iteration, the boxing cost appears to roughly double
the iteration times in these examples. While that sounds bad, consider the results in figure 8, which are for
the same test, but in that example the subsequent Garbage Collection times incurred after each test is
included. This presents a very different picture. In addition, iterating over a Morpheus array in parallel
is trivial and a fluent extension of the API, and in this mode, it appears that you double the performance
of native sequential execution on a Quad-Core machine. </p>
<p align="center">
    <img class="chart" src="../../images/native-vs-morpheus-array-sequential-vs-parallel1.png"/>
</p>

<p><strong>Figure 7. Morpheus boxing &amp; unboxing does come at a cost, but figure 8 shows the payoff</strong></p>
<p>Including the subsequent GC times after each test paints a very different picture. This also helps to
demonstrate the fact that the design compromise in the Morpheus library is sympathetic to the garbage collector,
because the boxing of dates during array traversal results in very short lived objects that are stack based. In
the native examples, the objects survive far longer and are heap based, thus placing a much bigger burden on
the collector. So while the number of objects created in each test is roughly equivalent, the native examples
take far longer overall.</p>
<p align="center">
    <img class="chart" src="../../images/native-vs-morpheus-array-sequential-vs-parallel2.png"/>
</p>

<p><strong>Figure 8. Including GC times completely changes the picture, and Morpheus proves much faster overall</strong></p>
<p>The code to generate the plots in figure 7 and 8 is as follows:</p>
<?prettify?>

<pre><code class="java">final int sample = 5;
final boolean includeGC = false;

Range&lt;Integer&gt; arrayLengths = Range.of(1, 11).map(i -&gt; i * 100000);
Array&lt;String&gt; labels = Array.ofStrings(&quot;Native(Seq)&quot;, &quot;Morpheus(Seq)&quot;, &quot;Native(Par)&quot;, &quot;Morpheus(Par)&quot;);
DataFrame&lt;String,String&gt; results = DataFrame.ofDoubles(arrayLengths.map(String::valueOf), labels);

arrayLengths.forEach(arrayLength -&gt; {

    DataFrame&lt;String,String&gt; timing = PerfStat.run(sample, TimeUnit.MILLISECONDS, includeGC, tasks -&gt; {

        tasks.put(&quot;Native(Seq)&quot;, () -&gt; {
            final AtomicInteger count = new AtomicInteger();
            final LocalDateTime start = LocalDateTime.now().minusYears(5);
            final LocalDateTime[] array = new LocalDateTime[arrayLength];
            for (int i=0; i&lt;array.length; ++i) {
                array[i] = start.plusMinutes(i);
            }
            for (LocalDateTime value : array) {
                if (value.getDayOfWeek() == DayOfWeek.MONDAY) {
                    count.incrementAndGet();
                }
            }
            return array;
        });

        tasks.put(&quot;Morpheus(Seq)&quot;, () -&gt; {
            final AtomicInteger count = new AtomicInteger();
            final LocalDateTime start = LocalDateTime.now().minusYears(5);
            final Array&lt;LocalDateTime&gt; array = Array.of(LocalDateTime.class, arrayLength);
            array.applyValues(v -&gt; start.plusMinutes(v.index()));
            array.forEach(value -&gt; {
                if (value.getDayOfWeek() == DayOfWeek.MONDAY) {
                    count.incrementAndGet();
                }
            });
            return array;
        });

        tasks.put(&quot;Native(Par)&quot;, () -&gt; {
            final AtomicInteger count = new AtomicInteger();
            final LocalDateTime start = LocalDateTime.now().minusYears(5);
            final IntStream indexes = IntStream.range(0, arrayLength).parallel();
            final Stream&lt;LocalDateTime&gt; dates = indexes.mapToObj(start::plusMinutes);
            final LocalDateTime[] array = dates.toArray(LocalDateTime[]::new);
            Stream.of(array).parallel().forEach(value -&gt; {
                if (value.getDayOfWeek() == DayOfWeek.MONDAY) {
                    count.incrementAndGet();
                }
            });
            return array;
        });

        tasks.put(&quot;Morpheus(Par)&quot;, () -&gt; {
            final AtomicInteger count = new AtomicInteger();
            final LocalDateTime start = LocalDateTime.now().minusYears(5);
            final Array&lt;LocalDateTime&gt; array = Array.of(LocalDateTime.class, arrayLength);
            array.parallel().applyValues(v -&gt; start.plusMinutes(v.index()));
            array.parallel().forEach(value -&gt; {
                if (value.getDayOfWeek() == DayOfWeek.MONDAY) {
                    count.incrementAndGet();
                }
            });
            return array;
        });

    });

    String label = String.valueOf(arrayLength);
    results.data().setDouble(label, &quot;Native(Seq)&quot;, timing.data().getDouble(&quot;Mean&quot;, &quot;Native(Seq)&quot;));
    results.data().setDouble(label, &quot;Morpheus(Seq)&quot;, timing.data().getDouble(&quot;Mean&quot;, &quot;Morpheus(Seq)&quot;));
    results.data().setDouble(label, &quot;Native(Par)&quot;, timing.data().getDouble(&quot;Mean&quot;, &quot;Native(Par)&quot;));
    results.data().setDouble(label, &quot;Morpheus(Par)&quot;, timing.data().getDouble(&quot;Mean&quot;, &quot;Morpheus(Par)&quot;));

});

//Create title from template
final String prefix = &quot;LocalDateTime Array Initialization + Traversal Times&quot;;
final String title = prefix + (includeGC ? &quot; (including-GC)&quot; : &quot; (excluding-GC)&quot;);

//Record chart to file
final String fileSuffix = includeGC ? &quot;2.png&quot; : &quot;1.png&quot;;
final String filePrefix = &quot;./docs/images/native-vs-morpheus-array-sequential-vs-parallel&quot;;

//Plot results as a bar chart
Chart.create().withBarPlot(results, false, chart -&gt; {
    chart.title().withText(title);
    chart.title().withFont(new Font(&quot;Verdana&quot;, Font.PLAIN, 15));
    chart.plot().axes().domain().label().withText(&quot;Array Length&quot;);
    chart.plot().axes().range(0).label().withText(&quot;Time (Milliseconds)&quot;);
    chart.legend().on();
    chart.writerPng(new File(filePrefix + fileSuffix), 845, 400, true);
    chart.show();
});
</code></pre>

<h4 id="sorting">Sorting</h4>
<p>This section compares some performance statistics of sorting large Morpheus arrays versus their
native counterparts. The Morpheus library is built around the highly versatile array sorting API
in <a href="http://fastutil.di.unimi.it/">FastUtil</a> developed by <a href="http://vigna.di.unimi.it/">Sebastiano Vigna</a>.
The results below compare performance versus the JDK <code>java.util.Arrays.sort()</code> and <code>parallelSort()</code>
functions, which it has to be said, is not an entirely fair benchmark.</p>
<p>Firstly, the JDK array sorting algorithm is based on a dual-pivot quick sort whereas FastUtil is based
on a more traditional single-pivot quick sort. Secondly, the JDK implementation is presented with
the array directly, allowing everything to be inlined, and also enabling sliced work arrays to
be constructed as required. FastUtil on the other hand is not presented with the data directly,
but interacts with it via an <code>IntComparator</code> and <code>Swapper</code>, which does incur method call over head,
but also makes it far more versatile. The JDK sorting functionality is limited to only sorting arrays
in their natural order, while FastUtil allows the sorting logic to be fully customized.</p>
<p>The results in Figure 9 and 10 demonstrate two very different outcomes, the former comparing performance
on a primitive <code>double</code> array, the latter on an <code>LocalDateTime</code> array (in both cases these arrays are
randomized before the tests are run). In the case of the double array, the JDK <code>Arrays</code> implementation
appears to offer roughly twice the performance of FastUtil as used in Morpheus. For the <code>LocalDateTime</code>
test, the tables are turned, and FastUtil vastly outperforms the native <code>Arrays</code> call, and these times
do not include any garbage collection costs incurred after the each test is completed.</p>
<p align="center">
    <img class="chart" src="../../images/array-sort-native-vs-morpheus-1.png"/>
</p>

<p><strong>Figure 9. Sorting times for an array of 10 million random double precision values</strong></p>
<p>In the <code>LocalDatTime</code> results below, Morpheus far outperforms the native array because it is only
operating on the internal primitive array of longs. No boxing is required here, so hence the vast
performance gap. While this is not an entirely fair comparison, it demonstrates the benefits of
storing everything as primitives. </p>
<p align="center">
    <img class="chart" src="../../images/array-sort-native-vs-morpheus-2.png"/>
</p>

<p><strong>Figure 10. Same test as in figure 9, but using an array of randomly ordered LocalDateTimes</strong></p>
<p>The code to generate the results in figure 9 is as follows:</p>
<?prettify?>

<pre><code class="java">Range&lt;Integer&gt; arrayLengths = Range.of(1, 11).map(i -&gt; i * 100000);
Array&lt;String&gt; labels = Array.ofStrings(&quot;Native(Seq)&quot;, &quot;Morpheus(Seq)&quot;, &quot;Native(Par)&quot;, &quot;Morpheus(Par)&quot;);
DataFrame&lt;String,String&gt; results = DataFrame.ofDoubles(arrayLengths.map(String::valueOf), labels);

arrayLengths.forEach(length -&gt; {

    System.out.println(&quot;Running sort test for array length &quot; + length);
    double[] array1 = new double[length];
    Array&lt;Double&gt; array2 = Array.of(Double.class, length);

    DataFrame&lt;String,String&gt; timing = PerfStat.run(sample, TimeUnit.MILLISECONDS, false, tasks -&gt; {
        tasks.put(&quot;Native(Seq)&quot;, () -&gt; { Arrays.sort(array1); return array1; });
        tasks.put(&quot;Morpheus(Seq)&quot;, () -&gt; array2.sort(true) );
        tasks.put(&quot;Native(Par)&quot;, () -&gt; { Arrays.parallelSort(array1); return array1; });
        tasks.put(&quot;Morpheus(Par)&quot;, () -&gt; array2.parallel().sort(true));
        tasks.beforeEach(() -&gt; {
            array2.applyDoubles(v -&gt; Math.random());
            array2.forEachValue(v -&gt; array1[v.index()] = v.getDouble());
        });
    });

    String label = String.valueOf(length);
    results.data().setDouble(label, &quot;Native(Seq)&quot;, timing.data().getDouble(&quot;Mean&quot;, &quot;Native(Seq)&quot;));
    results.data().setDouble(label, &quot;Morpheus(Seq)&quot;, timing.data().getDouble(&quot;Mean&quot;, &quot;Morpheus(Seq)&quot;));
    results.data().setDouble(label, &quot;Native(Par)&quot;, timing.data().getDouble(&quot;Mean&quot;, &quot;Native(Par)&quot;));
    results.data().setDouble(label, &quot;Morpheus(Par)&quot;, timing.data().getDouble(&quot;Mean&quot;, &quot;Morpheus(Par)&quot;));
});

Chart.create().withBarPlot(results, false, chart -&gt; {
    chart.title().withText(&quot;Sorting Performance for Array of Random LocalDateTimes (Sample &quot; + sample + &quot;)&quot;);
    chart.title().withFont(new Font(&quot;Verdana&quot;, Font.PLAIN, 16));
    chart.subtitle().withText(&quot;Dual-Pivot Quick Sort (Native) vs Single-Pivot Quick Sort (FastUtil)&quot;);
    chart.subtitle().withFont(new Font(&quot;Verdana&quot;, Font.PLAIN, 14));
    chart.plot().axes().domain().label().withText(&quot;Array Length&quot;);
    chart.plot().axes().range(0).label().withText(&quot;Total Time in Milliseconds&quot;);
    chart.legend().on();
    chart.show();
});
</code></pre>

<h4 id="summary-statistics">Summary Statistics</h4>
<p>Morpheus provides an API to calculate various descriptive statistics on numerical arrays, such
as min, max, variance, skew, kurtosis, auto correlation and so on. The chart below shows the
calculation times for these quantities on a Morpheus array of 10 million random double precision
values. The code used to generate this plot is also included.</p>
<p align="center">
    <img class="chart" src="../../images/morpheus-stat-times.png"/>
</p>

<p><strong>Figure 11. Calculation times for various summary statistics on a Morpheus array with 10 million elements</strong></p>
<p>The code to generate these results is as follows:</p>
<?prettify?>

<pre><code class="java">final int count = 10;
final int size = 10000000;
final Array&lt;Double&gt; array = Array.of(Double.class, size).applyDoubles(v -&gt; Math.random() * 100);

final DataFrame&lt;String,String&gt; times = PerfStat.run(count, TimeUnit.MILLISECONDS, true, tasks -&gt; {
    tasks.put(&quot;Min&quot;, () -&gt; array.stats().min());
    tasks.put(&quot;Max&quot;, () -&gt; array.stats().max());
    tasks.put(&quot;Mean&quot;, () -&gt; array.stats().mean());
    tasks.put(&quot;Count&quot;, () -&gt; array.stats().count());
    tasks.put(&quot;Variance&quot;, () -&gt; array.stats().variance());
    tasks.put(&quot;StdDev&quot;, () -&gt; array.stats().stdDev());
    tasks.put(&quot;Sum&quot;, () -&gt; array.stats().sum());
    tasks.put(&quot;Skew&quot;, () -&gt; array.stats().skew());
    tasks.put(&quot;Kurtosis&quot;, () -&gt; array.stats().kurtosis());
    tasks.put(&quot;Median&quot;, () -&gt; array.stats().median());
    tasks.put(&quot;95th Percentile&quot;, () -&gt; array.stats().percentile(95));
    tasks.put(&quot;AutCorrelation(20)&quot;, () -&gt; array.stats().autocorr(20));
});

Chart.create().withBarPlot(times.rows().select(&quot;Mean&quot;).transpose(), false, chart -&gt; {
    chart.title().withText(&quot;Morpheus Array Statistic Calculation Times, 10 Million Entries (Sample 10)&quot;);
    chart.title().withFont(new Font(&quot;Verdana&quot;, Font.PLAIN, 15));
    chart.plot().axes().domain().label().withText(&quot;Stat Type&quot;);
    chart.plot().axes().range(0).label().withText(&quot;Time (Milliseconds)&quot;);
    chart.plot().orient().horizontal();
    chart.legend().off();
    chart.show();
});
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright (C) 2014-2017 Xavier Witdouck</p>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '../..';</script>
        <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
        <script src="../../js/base.js"></script>
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script src="http://www.zavtech.com/morpheus/docs/javascript/analytics.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
